<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Yet Another C++20 Coroutine Tutorial</title>
		<meta name="description" content="A deep dive into how C++20 coroutines work under the hood.">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="pandarin.dev">
		
		
		
		<style>/* This is an arbitrary CSS string added to the bundle */
/* Defaults */
:root {
	--font-family: -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
}

/* Theme colors */
:root {
	--color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333;

	--background-color: #fff;

	--text-color: var(--color-gray-90);
	--text-color-link: #082840;
	--text-color-link-active: #5f2b48;
	--text-color-link-visited: #17050F;

	--syntax-tab-size: 2;
}

@media (prefers-color-scheme: dark) {
	:root {
		--color-gray-20: #e0e0e0;
		--color-gray-50: #C0C0C0;
		--color-gray-90: #dad8d8;

		/* --text-color is assigned to --color-gray-_ above */
		--text-color-link: #1493fb;
		--text-color-link-active: #6969f7;
		--text-color-link-visited: #a6a6f8;

		--background-color: #15202b;
	}
}


/* Global stylesheet */
* {
	box-sizing: border-box;
}

@view-transition {
	navigation: auto;
}

html,
body {
	padding: 0;
	margin: 0 auto;
	font-family: var(--font-family);
	color: var(--text-color);
	background-color: var(--background-color);
}
html {
	overflow-y: scroll;
}
body {
	max-width: 50em;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden:not(:focus):not(:active) {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

/* Fluid images via https://www.zachleat.com/web/fluid-images/ */
img{
  max-width: 100%;
}
img[width][height] {
  height: auto;
}
img[src$=".svg"] {
  width: 100%;
  height: auto;
  max-width: none;
}
video,
iframe {
	width: 100%;
	height: auto;
}
iframe {
	aspect-ratio: 16/9;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

li {
	line-height: 1.5;
}

a[href] {
	color: var(--text-color-link);
}
a[href]:visited {
	color: var(--text-color-link-visited);
}
a[href]:hover,
a[href]:active {
	color: var(--text-color-link-active);
}

main,
footer {
	padding: 1rem;
}
main :first-child {
	margin-top: 0;
}

header {
	border-bottom: 1px dashed var(--color-gray-20);
}

#skip-link {
	text-decoration: none;
	background: var(--background-color);
	color: var(--text-color);
	padding: 0.5rem 1rem;
	border: 1px solid var(--color-gray-90);
	border-radius: 2px;
}

/* Prevent visually-hidden skip link fom pushing content around when focused */
#skip-link.visually-hidden:focus {
	position: absolute;
	top: 1rem;
	left: 1rem;
	/* Ensure it is positioned on top of everything else when it is shown */
	z-index: 999;
}

.links-nextprev {
	display: flex;
	justify-content: space-between;
	gap: .5em 1em;
	list-style: "";
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}
.links-nextprev > * {
	flex-grow: 1;
}
.links-nextprev-next {
	text-align: right;
}

table {
	margin: 1em 0;
}
table td,
table th {
	padding-right: 1em;
}

pre,
code {
	font-family: var(--font-family-monospace);
}
pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	overflow-x: auto;
}
code {
	word-break: break-all;
}

/* Header */
header {
	display: flex;
	gap: 1em;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	padding: 1em;
}
.home-link {
	flex-grow: 1;
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
.nav {
	display: flex;
	gap: .5em 1em;
	padding: 0;
	margin: 0;
	list-style: none;
}
.nav-item {
	display: inline-block;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}

/* Posts list */
.postlist {
	counter-reset: start-from var(--postlist-index);
	list-style: none;
	padding: 0;
	padding-left: 1.5rem;
}
.postlist-item {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	counter-increment: start-from -1;
	margin-bottom: 1em;
}
.postlist-item:before {
	display: inline-block;
	pointer-events: none;
	content: "" counter(start-from, decimal-leading-zero) ". ";
	line-height: 100%;
	text-align: right;
	margin-left: -1.5rem;
}
.postlist-date,
.postlist-item:before {
	font-size: 0.8125em; /* 13px /16 */
	color: var(--color-gray-90);
}
.postlist-date {
	word-spacing: -0.5px;
}
.postlist-link {
	font-size: 1.1875em; /* 19px /16 */
	font-weight: 700;
	flex-basis: calc(100% - 1.5rem);
	padding-left: .25em;
	padding-right: .5em;
	text-underline-position: from-font;
	text-underline-offset: 0;
	text-decoration-thickness: 1px;
}
.postlist-item-active .postlist-link {
	font-weight: bold;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	text-transform: capitalize;
	font-style: italic;
}
.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	gap: .5em;
	list-style: none;
	padding: 0;
	margin: 0;
}
.post-metadata time {
	margin-right: 1em;
}
/**
 * okaidia theme for JavaScript, CSS and HTML
 * Loosely based on Monokai textmate theme by http://www.monokai.nl/
 * @author ocodia
 */

code[class*="language-"],
pre[class*="language-"] {
	color: #f8f8f2;
	background: none;
	text-shadow: 0 1px rgba(0, 0, 0, 0.3);
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
	border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #272822;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: #8292a2;
}

.token.punctuation {
	color: #f8f8f2;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.constant,
.token.symbol,
.token.deleted {
	color: #f92672;
}

.token.boolean,
.token.number {
	color: #ae81ff;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #a6e22e;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string,
.token.variable {
	color: #f8f8f2;
}

.token.atrule,
.token.attr-value,
.token.function,
.token.class-name {
	color: #e6db74;
}

.token.keyword {
	color: #66d9ef;
}

.token.regex,
.token.important {
	color: #fd971f;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
/*
 * New diff- syntax
 */

pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}</style>
		
	</head>
	<body>
		<a href="#main" id="skip-link" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">pandarin.dev</a>
			<nav>
				<h2 class="visually-hidden" id="top-level-navigation-menu">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/blog/">Archive</a></li>
					<li class="nav-item"><a href="/about/">About</a></li>
					<li class="nav-item"><a href="/feed/feed.xml">Feed</a></li>
				</ul>
			</nav>
		</header>

		<main id="main">
			<heading-anchors>
				


<h1 id="yet-another-c-20-coroutine-tutorial">Yet Another C++20 Coroutine Tutorial</h1>

<ul class="post-metadata">
	<li><time datetime="2025-07-23">23 July 2025</time></li>
	<li><a href="/tags/c/" class="post-tag">c++</a></li>
</ul>

<br>
Written by <a href="/about">Krisztián Szabó</a>

<h1 id="preamble">Preamble</h1>
<p>C++20 adds a bunch of cool new features to an already complicated language full of footguns: Concepts, modules, <a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/">spaceships</a> and even coroutines.
While most of the new features are relatively straightforward, coroutines are not.
This is further proven by the myriad of existing coroutine tutorials and guides already present on the internet. Everyone and their dog seemingly wants to write an article on coroutines, so I figured why not pile on?!</p>
<p>To be honest I found most of the existing documentation and guides unnecessarily complicated and confusing (often even misleading or straight up wrong), so I figured I'll try to explain things my way, and hopefully make things easier to grasp for people.</p>
<p>This is going to be a long article and I firmly believe this is a topic that cannot be taught in short form, so grab a snack and drink and read on. I promise I'll try to make this as short and painless as possible, but this is complicated topic, so it will require some patience and head scratching from you as well. Do not feel bad if something is not immediately obvious to you, it took me multiple attempts to mostly understand the things I write about here.</p>
<h1 id="theory">Theory</h1>
<p>In order to clear up confusion and start from a common ground I want to start with some theory. I know you are just about to scroll past this to see some code, but don't. If you do, you will be banging your head on your desk in confusion, I will point at you specifically and say the ugly words &quot;I told you so&quot; with a smug smile.</p>
<h2 id="what-are-coroutines">What are coroutines?</h2>
<p>Coroutines often confuse developers as a concept - most devs have heard about them, but have only foggy, vague definitions for them. Let me clear that up in one sentence:</p>
<p><strong>A coroutine is a function that can be suspended and resumed at will.</strong> That's it.</p>
<p>It is essentially a control flow mechanism, where you can say &quot;lets give back control to the caller of this function, and if it wants to, it can later resume this function exactly in the state that it was left in&quot;.</p>
<p>One thing that often confuses developers is &quot;suspension&quot; and &quot;resuming&quot;, somehow thinking that either of those have anything to do with parallel programming and threads. <strong>They do not.</strong> When you suspend a coroutine control is handed back to the caller and when you resume a coroutine you do not spawn a new thread or anything like that - it is just like any other function call, except you will resume that function in the same state it was supended in (from the same line, with it's state variables being the same).</p>
<p>This already should make experienced engineers scratch their heads - how can you resume a function from the state that it was left in without threads and context switching? Well, the answer is that you store the state of the function not on the stack as you would normally do, but on a separate frame that is heap allocated. That frame has to be large enough to store state variables of the function as well as an &quot;instruction pointer&quot; that tells the coroutine mechanism where to continue the function from.</p>
<h2 id="but-i-thought-coroutines-are-a-way-to-make-parallel-programs-more-efficient">But I thought coroutines are a way to make parallel programs more efficient?!</h2>
<p>Yes and no. The reason why many developers are confused by this is because coroutines are often used in conjunction with threads to make parallelism more efficient through a concept called <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">&quot;cooperative multitasking&quot;</a>. Coroutines are a key part of writing efficient parallel programs, and coroutines and thread(pool)s go together like peanut butter and jelly. But just like peanut butter is not jelly, coroutines are not threads.</p>
<p>Without going into too much detail before you understand the full theory, when you are waiting for something (e.g. reading a chunk of bytes from a socket) you can tell the kernel to begin the reading operation, then suspend the coroutine, and as such, return the control back to the caller - which is often a thread in a thread pool when working on parallel programs.</p>
<p>This way the thread in the pool is not blocked while we are reading the bytes, it can pick up a new task and start executing it. When the kernel finished reading that chunk of bytes we told it to read, it will flag the data available, for which we'll have a way of detection in place and mark the coroutine ready to run again (but not resume it immediately). This way when a thread in the threadpool is looking for work again it will see that the task is ready to be resumed and will call <code>.resume()</code> on the coroutine handle to resume it exactly from the same state.</p>
<p>The brilliance of this - and the entire point of coroutines - is this not only you get to utilize your threads more efficiently, but also this way you get to avoid chaining together async operations by passing down lambdas everywhere as callbacks (aka <a href="https://medium.com/@raihan_tazdid/callback-hell-in-javascript-all-you-need-to-know-296f7f5d3c1">&quot;callback hell&quot;</a>). You just write your function as you would normally do, the &quot;coroutine runtime&quot; will take care of the rest.</p>
<p>It is also super important to mention at this point that in C++20 coroutines are just a language feature, there is no library support, there is no runtime built-in. If that's what you are after, take a look at something like <a href="https://github.com/lewissbaker/cppcoro">cppcoro</a> once you read this article and understood coroutines.</p>
<h2 id="how-c-coroutines-work">How C++ coroutines work</h2>
<p>Let me start off by explaining how the C++20 coroutine mechanism works. You are not supposed to understand this fully yet and I do encourage you to scroll back to this section occasionally and check your understanding against this chapter.</p>
<p>In order to define a coroutine you need a function - it only makes sense, after all coroutines are just suspendable functions. In other languages you often need to prefix these functions with keywords such as <code>async</code>, but not in C++, we do not have any keywords in the function signature for coroutines.</p>
<p>What makes a coroutine a coroutine in C++ however, is that it has at least 1 of 3 keywords in its function body: <code>co_await</code>/<code>co_yield</code>/<code>co_return</code>. It needs at least one of those, otherwise the function will not be considered a coroutine by the compiler.</p>
<p>Of course with any good function, you'll also need to define a return type (functions returning void cannot be coroutines, you'll see why). The C++ compiler will put restrictions on what return type you can use for coroutines: The return type is required to have a member called <code>promise_type</code>. That is the only restriction the return type needs to fulfill. However, the <code>promise_type</code> in turn is required to have much more logic:</p>
<ul>
<li>It must have a <code>get_return_object</code> function that returns the return object of the coroutine</li>
<li>It must have a <code>initial_suspend</code> function that returns an awaitable</li>
<li>It must have a <code>final_suspend</code> function that returns an awaitable and is non-throwing (<code>noexcept</code>)</li>
<li>It must have either a <code>return_void</code> or <code>return_value</code> function that unintuitively returns nothing</li>
<li>It must have an <code>unhandled_exception</code> function</li>
</ul>
<p>The last piece of this puzzle (for now) is the <code>std::coroutine_handle&lt;promise_type&gt;</code> that is a handle to the coroutine itself. This coroutine handle object is the one that has the heap allocated frame inside for the function. You can use the handle to <code>.resume()</code> the coroutine or <code>.destroy()</code> it to deallocate the coroutine frame (if the coroutine is suspended, otherwise UB).</p>
<p>When you call a coroutine the compiler expands that function call and spices in some magic. That magic is:</p>
<ul>
<li>it alloces the coroutine frame on the heap</li>
<li>it instantiates the promise type (which it figures out from the return type's <code>promise_type</code> member)</li>
<li>it instantiates the return object using <code>promise.get_return_object()</code></li>
<li>it checks whether the coroutine needs to be immediately suspended by calling <code>promise.initial_suspend()</code></li>
<li>if an exception happens in the function body <code>promise.unhandled_exception()</code> is called</li>
<li>once the execution is complete either by reaching the end of the function or a <code>co_return</code> the mechanism checks if the coroutine needs to be suspended one final time by calling <code>promise.final_suspend()</code></li>
</ul>
<p>Let us see an example.</p>
<h1 id="the-simplest-possible-coroutine-in-c-20">The simplest possible coroutine in C++20</h1>
<pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">example_return_type</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> example_return_type<span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span><span class="token class-name">coroutine_handle</span><span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_never <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span> handle<span class="token punctuation">;</span>

    <span class="token operator">~</span><span class="token function">example_return_type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            handle<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

example_return_type <span class="token function">my_first_coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">co_return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> my_return_obj <span class="token operator">=</span> <span class="token function">my_first_coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><a href="https://godbolt.org/z/xbE4nc8hT">[Try it out on Godbolt]</a></p>
<p>Rolls off the tongue, doesn't it? Let us take in order what this does.</p>
<ul>
<li>we have <code>example_return_type</code> for the return type, that holds the handle to the coroutine</li>
<li>inside we define <code>promise_type</code> that does the following:
<ul>
<li>defines <code>get_return_object()</code> that returns an instance of <code>example_return_type</code> holding a handle created from the promise
<ul>
<li>this is because coroutine handles are non-owning, you can think of them as pointers to promises</li>
</ul>
</li>
<li>specifies <code>std::suspend_never</code> for <code>initial_suspend()</code>, meaning that we do not want to immediately suspend the function, keep executing it please</li>
<li>specifies <code>std::suspend_always</code> for <code>final_suspend()</code>, meaning we do actually want to suspend the coroutine once it finishes executing</li>
<li>defines <code>return_void()</code> that gets called when, well... when we return a void using <code>co_return;</code> in the function
<ul>
<li>you can think of it as a listener, in case you want to set something in the promise when a coroutine returns</li>
</ul>
</li>
<li>defines <code>unhandled_exception()</code> as an empty function, hoping nothing bad would happen (of course don't do this in production)</li>
</ul>
</li>
<li>in the destructor of <code>example_return_type</code> we check if the coroutine handle points to a valid coroutine and <code>.destroy()</code> its heap allocated frame if it does
<ul>
<li>this is the reason why we specified <code>suspend_always</code> for <code>final_suspend</code>, destroying is only ever legal on suspended coroutines</li>
</ul>
</li>
<li>finally, we define the coroutine itself in the form of <code>my_first_coroutine</code>
<ul>
<li>the function actually does nothing, but we need to specify <code>co_return</code> in it for the compiler to recognize as a coroutine</li>
<li><code>co_await</code> or <code>co_yield</code> would also work, but they do not make sense in the context of this function</li>
</ul>
</li>
</ul>
<h1 id="what-is-an-awaiter">What is an awaiter?</h1>
<p>Now that we've seen the simplest possible coroutine let us also see an example for a coroutine that actually does something.
In order to demonstrate <code>co_await</code> we need to understand &quot;awaitables&quot; and how <code>co_await</code> works. When we call <code>co_await</code> we always need supply an awaiter as an argument and that awaiter will dictate whether or not we are actually going to suspend execution. This means that just because you see a <code>co_await</code> it doesn't necessarily mean that execution will be suspended - it is a <strong>potential</strong> suspension point.</p>
<p>Previously we have used <code>std::suspend_always</code> and <code>std::suspend_never</code> from the standard library for awaitables, but now we are going define our own.</p>
<p>An awaitable needs to define 3 things:</p>
<ul>
<li>an <code>await_ready()</code> function that returns a boolean
<ul>
<li>if <code>true</code> there is no need to suspend, whatever we are waiting for is already ready, resume the coroutine</li>
<li>if <code>false</code> suspend the coroutine</li>
</ul>
</li>
<li>an <code>await_suspend()</code> function
<ul>
<li>this function is called when the coroutine is suspended, think of it as a &quot;suspension listener&quot;</li>
<li>this function receives the <code>std::coroutine_handle&lt;promise_type&gt;</code> as an argument
<ul>
<li>this is useful in case you want to manipulate the promise object or if you want to forward the handle somewhere to <code>.resume()</code> it from there later</li>
</ul>
</li>
<li>for now lets just say the return type is <code>void</code>, but it can get more complicated in advanced use cases</li>
</ul>
</li>
<li>an <code>await_resume()</code> function
<ul>
<li>this function is called when a coroutine is resumed, think of it as a &quot;resume listener&quot;</li>
<li>the return value of this function will be the return value of the <code>co_await</code></li>
</ul>
</li>
</ul>
<p>Armed with this knowledge we could write <code>std::suspend_always</code> ourselves trivially. Lets do that as a practice example.</p>
<pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">suspend_always</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token function">await_ready</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">await_suspend</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span><span class="token operator">></span> handle<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">await_resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>We simply return <code>false</code> when asked if the thing we are waiting for is ready, thus triggering the suspension of the coroutine. Also we don't do anything when the coroutine gets suspended or resumed.</p>
<p>Of course this is a boring (but useful) awaiter, but we can use it to demonstrate something more novel.</p>
<pre class="language-cpp" tabindex="0"><code class="language-cpp">example_return_type <span class="token function">my_second_coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello "</span><span class="token punctuation">;</span>
    <span class="token keyword">co_await</span> std<span class="token double-colon punctuation">::</span>suspend_always<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"world"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> return_obj <span class="token operator">=</span> <span class="token function">my_second_coroutine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"beautiful "</span><span class="token punctuation">;</span>
    return_obj<span class="token punctuation">.</span>handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><a href="https://godbolt.org/z/c4zeG56EM">[Try it out on Godbolt]</a></p>
<p>This is the point in the article where you first truly get to test your understanding of the things you read so far. What will this program print to standard out?</p>
<p>Of course the answer is somewhat obviously &quot;Hello beautiful world&quot;, but lets break it down.</p>
<ul>
<li>We first call <code>my_second_coroutine()</code></li>
<li>Because we previously defined <code>initial_suspend</code> as <code>std::suspend_never</code> on <code>example_return_type::promise_type</code>, execution begins</li>
<li>We print &quot;Hello &quot;</li>
<li>We <code>co_await std::suspend_always{}</code> which returns <code>false</code> for <code>await_ready()</code>, suspending the coroutine</li>
<li>Control gets transferred back to <code>main</code>, we print &quot;beautiful &quot;</li>
<li>We resume the coroutine using <code>return_obj.handle.resume()</code> which first calls <code>await_resume()</code> on the awaited <code>std::suspend_always</code> instance</li>
<li>Execution of the coroutine continues, printing &quot;world&quot;</li>
<li><code>return_void</code> is called on the promise object</li>
<li><code>final_suspend</code> is called on the promise object, suspending the coroutine</li>
<li>When the return object goes out-of-scope we <code>.destroy()</code> the coroutine frame</li>
</ul>
<p>At this point you should understand <code>co_await</code>, how suspension and resuming transfers the control flow back and forth between the caller and the coroutine, and the role that awaiters play in that.</p>
<h1 id="let-us-write-a-generator">Let us write a generator</h1>
<p>Generators are a thing that can be very well modelled using a coroutine and are a great candidate for demonstrating <code>co_yield</code>.</p>
<p>We will write the simplest possible generator that will return an integer value that gets incremented with every call.</p>
<pre class="language-cpp" tabindex="0"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">generator_t</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">promise_type</span> <span class="token punctuation">{</span>

        <span class="token keyword">int</span> current_value<span class="token punctuation">;</span>

        <span class="token keyword">auto</span> <span class="token function">get_return_object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> generator_t<span class="token punctuation">{</span>
                std<span class="token double-colon punctuation">::</span><span class="token class-name">coroutine_handle</span><span class="token operator">&lt;</span>promise_type<span class="token operator">></span><span class="token double-colon punctuation">::</span><span class="token function">from_promise</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_always <span class="token function">initial_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_always <span class="token function">final_suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">return_void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token function">unhandled_exception</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        std<span class="token double-colon punctuation">::</span>suspend_always <span class="token function">yield_value</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            current_value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>coroutine_handle<span class="token operator">&lt;</span>promise_type<span class="token operator">></span> handle<span class="token punctuation">;</span>

    <span class="token operator">~</span><span class="token function">generator_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>handle<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            handle<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        handle<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> handle<span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>current_value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

generator_t <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token keyword">co_yield</span> x<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> gen_obj <span class="token operator">=</span> <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">gen_obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 0</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">gen_obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 1</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">gen_obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 2</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><a href="https://godbolt.org/z/qcbrba8KE">[Try it out on Godbolt]</a></p>
<p>As you can see when we are using <code>co_yield</code> in the generator function, it will call a function that is newly defined in our <code>promise_type</code>: <code>yield_value()</code>.
Now the interesting thing about <code>yield_value</code> is that it does not actually yield anything, it is just a listener that gets called whenever the function yields something. This is because <code>co_yield &lt;expression&gt;;</code> is just syntactic sugar for <code>co_await yield_value(expression);</code>.</p>
<p>The approach that I chose here is that during the yield I store the value in the promise, then define an <code>operator()</code> on the return object which will simply resume the coroutine until the next suspension point, then return the value stored in the promise object.</p>
<p>Breaking this down we get:</p>
<ul>
<li>we call <code>generator()</code> which gets immediately suspended because <code>initial_suspend()</code> is <code>std::suspend_always</code></li>
<li>control immediately returns to <code>main</code></li>
<li>we call the <code>operator()</code> of the return object (repeatedly), each time resuming the coroutine which will execute until the next <code>co_yield</code> statement</li>
<li>at that point <code>yield_value()</code> stores the yielded value in the promise</li>
<li>because the returned awaitable of <code>yield_value()</code> is <code>std::suspend_always</code> the coroutine is suspended and control returns to <code>operator()</code> of the return object</li>
<li>the <code>operator()</code> will return the stored value from the promise which we print out in <code>main</code></li>
</ul>
<h1 id="my-thoughts-on-coroutines-in-c-20">My thoughts on coroutines in C++20</h1>
<p>And with that it's a wrap. We have talked about coroutines, handles, promises, awaitables, <code>co_await</code>/<code>co_yield</code>/<code>co_return</code> and more. At this point the only thing left to do is editorializing this article a bit by talking about my feelings with regards to coroutines as they are in C++20.</p>
<p>While I'm glad the feature is there, and no doubt it will be useful for highly parallel programs I can't help but feel that in typical C++ fashion the feature is overly complicated and verbose.</p>
<p>I get that library support is yet to come, and as such this is a barebones way of interacting with coroutines, but do you know how the same generator example looks like in Python? I will show you now out of spite.</p>
<pre class="language-python" tabindex="0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    x <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span> x
        x <span class="token operator">+=</span> <span class="token number">1</span>

gen_obj <span class="token operator">=</span> generator<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>gen_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 0</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>gen_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>gen_obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 2</span></code></pre>
<p>This is it. This is how simple I expected C++ coroutines to be when they were announced. Of course Python being an interpreted language this is a bit of an unfair comparison, but you get the point.</p>
<p>Anyways, I'll let everyone make up their own mind about how they feel about the implementation of the feature, I only wanted to clarify the concept through this article. In case any of my examples make no sense to you, if you have any questions or you spotted a mistake feel free to reach out.</p>
<p>Have a great day, and thanks for taking the time to read through all this, hope you learned something.</p>


			</heading-anchors>
		</main>

		<!-- This page `/blog/2025-07-23-cpp20-coroutines/` was built on 2025-07-24T07:44:25.591Z -->
		<script type="module" src="/dist/xbxy_EL6cU.js"></script>
	</body>
</html>
